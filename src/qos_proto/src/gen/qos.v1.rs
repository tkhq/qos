// This file is @generated by prost-build.
/// Enclave configuration specific to AWS Nitro.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NitroConfig {
    /// Hash of the enclave image file (PCR0)
    #[prost(bytes = "vec", tag = "1")]
    pub pcr0: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the Linux kernel and bootstrap (PCR1)
    #[prost(bytes = "vec", tag = "2")]
    pub pcr1: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the application (PCR2)
    #[prost(bytes = "vec", tag = "3")]
    pub pcr2: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the IAM role ARN (PCR3)
    #[prost(bytes = "vec", tag = "4")]
    pub pcr3: ::prost::alloc::vec::Vec<u8>,
    /// DER encoded X509 AWS root certificate
    #[prost(bytes = "vec", tag = "5")]
    pub aws_root_certificate: ::prost::alloc::vec::Vec<u8>,
    /// Reference to the commit QOS was built off of
    #[prost(string, tag = "6")]
    pub qos_commit: ::prost::alloc::string::String,
}
/// Pivot binary configuration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PivotConfig {
    /// SHA-256 hash of the pivot binary
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// Restart policy for running the pivot binary
    #[prost(enumeration = "RestartPolicy", tag = "2")]
    pub restart: i32,
    /// Arguments to invoke the binary with
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A quorum member's alias and public key.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuorumMember {
    /// Human readable alias to identify the member
    #[prost(string, tag = "1")]
    pub alias: ::prost::alloc::string::String,
    /// P256 public key bytes
    #[prost(bytes = "vec", tag = "2")]
    pub pub_key: ::prost::alloc::vec::Vec<u8>,
}
/// A member of a quorum set identified solely by their public key.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemberPubKey {
    /// P256 public key bytes
    #[prost(bytes = "vec", tag = "1")]
    pub pub_key: ::prost::alloc::vec::Vec<u8>,
}
/// The Manifest Set - members who can approve manifests.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManifestSet {
    /// Threshold K of signatures necessary for quorum
    #[prost(uint32, tag = "1")]
    pub threshold: u32,
    /// Members composing the set (N >= K)
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<QuorumMember>,
}
/// The Share Set - members who hold key shares.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareSet {
    /// Threshold K of signatures necessary for quorum
    #[prost(uint32, tag = "1")]
    pub threshold: u32,
    /// Members composing the set (N >= K)
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<QuorumMember>,
}
/// The Patch Set - members who can approve patches.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchSet {
    /// Threshold K of signatures necessary for quorum
    #[prost(uint32, tag = "1")]
    pub threshold: u32,
    /// Public keys of members (N >= K)
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<MemberPubKey>,
}
/// A Namespace and its relative nonce.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Namespace {
    /// Unique namespace name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Monotonically increasing nonce to prevent downgrade attacks
    #[prost(uint32, tag = "2")]
    pub nonce: u32,
    /// P256 quorum key public bytes
    #[prost(bytes = "vec", tag = "3")]
    pub quorum_key: ::prost::alloc::vec::Vec<u8>,
}
/// The Manifest for the enclave.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Manifest {
    /// Namespace this manifest belongs to
    #[prost(message, optional, tag = "1")]
    pub namespace: ::core::option::Option<Namespace>,
    /// Pivot binary configuration
    #[prost(message, optional, tag = "2")]
    pub pivot: ::core::option::Option<PivotConfig>,
    /// Manifest Set members and threshold
    #[prost(message, optional, tag = "3")]
    pub manifest_set: ::core::option::Option<ManifestSet>,
    /// Share Set members and threshold
    #[prost(message, optional, tag = "4")]
    pub share_set: ::core::option::Option<ShareSet>,
    /// Enclave hardware configuration
    #[prost(message, optional, tag = "5")]
    pub enclave: ::core::option::Option<NitroConfig>,
    /// Patch set members and threshold
    #[prost(message, optional, tag = "6")]
    pub patch_set: ::core::option::Option<PatchSet>,
    /// Client timeout for calls via the VSOCK/USOCK (optional, defaults to 5s)
    #[prost(uint32, optional, tag = "7")]
    pub client_timeout_ms: ::core::option::Option<u32>,
    /// Pool size for socket pipes (optional, defaults to 1)
    #[prost(uint32, optional, tag = "8")]
    pub pool_size: ::core::option::Option<u32>,
}
/// An approval by a Quorum Member.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Approval {
    /// P256 ECDSA signature over the manifest hash
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The quorum member who signed
    #[prost(message, optional, tag = "2")]
    pub member: ::core::option::Option<QuorumMember>,
}
/// Manifest with accompanying Approvals.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManifestEnvelope {
    /// Encapsulated manifest
    #[prost(message, optional, tag = "1")]
    pub manifest: ::core::option::Option<Manifest>,
    /// Approvals from the manifest set
    #[prost(message, repeated, tag = "2")]
    pub manifest_set_approvals: ::prost::alloc::vec::Vec<Approval>,
    /// Approvals from the share set (for audit)
    #[prost(message, repeated, tag = "3")]
    pub share_set_approvals: ::prost::alloc::vec::Vec<Approval>,
}
/// Policy for restarting the pivot binary.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RestartPolicy {
    Unspecified = 0,
    Never = 1,
    Always = 2,
}
impl RestartPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESTART_POLICY_UNSPECIFIED",
            Self::Never => "RESTART_POLICY_NEVER",
            Self::Always => "RESTART_POLICY_ALWAYS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESTART_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "RESTART_POLICY_NEVER" => Some(Self::Never),
            "RESTART_POLICY_ALWAYS" => Some(Self::Always),
            _ => None,
        }
    }
}
/// Configuration for sharding a Quorum Key created in the Genesis flow.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisSet {
    /// Share Set Members whose keys will be used to encrypt outputs
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<QuorumMember>,
    /// Threshold for successful reconstitution of the Quorum Key shards
    #[prost(uint32, tag = "2")]
    pub threshold: u32,
}
/// A member shard - internal type for recovery permutations.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemberShard {
    /// Member of the Setup Set
    #[prost(message, optional, tag = "1")]
    pub member: ::core::option::Option<QuorumMember>,
    /// Shard encrypted to the member's key
    #[prost(bytes = "vec", tag = "2")]
    pub shard: ::prost::alloc::vec::Vec<u8>,
}
/// A set of member shards used to successfully recover the quorum key.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecoveredPermutation {
    /// The shards that were used for recovery
    #[prost(message, repeated, tag = "1")]
    pub shards: ::prost::alloc::vec::Vec<MemberShard>,
}
/// Genesis output per Setup Member.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisMemberOutput {
    /// The Quorum Member whose Setup Key was used
    #[prost(message, optional, tag = "1")]
    pub share_set_member: ::core::option::Option<QuorumMember>,
    /// Quorum Key Share encrypted to the member's Personal Key
    #[prost(bytes = "vec", tag = "2")]
    pub encrypted_quorum_key_share: ::prost::alloc::vec::Vec<u8>,
    /// SHA-512 hash of the plaintext quorum key share (for verification)
    #[prost(bytes = "vec", tag = "3")]
    pub share_hash: ::prost::alloc::vec::Vec<u8>,
}
/// Output from running Genesis Boot.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisOutput {
    /// Public Quorum Key, DER encoded
    #[prost(bytes = "vec", tag = "1")]
    pub quorum_key: ::prost::alloc::vec::Vec<u8>,
    /// Quorum Member specific outputs from the genesis ceremony
    #[prost(message, repeated, tag = "2")]
    pub member_outputs: ::prost::alloc::vec::Vec<GenesisMemberOutput>,
    /// All successfully recovered permutations during genesis
    #[prost(message, repeated, tag = "3")]
    pub recovery_permutations: ::prost::alloc::vec::Vec<RecoveredPermutation>,
    /// The threshold K used to generate the shards
    #[prost(uint32, tag = "4")]
    pub threshold: u32,
    /// The quorum key encrypted to the DR key (if DR key was provided)
    #[prost(bytes = "vec", optional, tag = "5")]
    pub dr_key_wrapped_quorum_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// SHA-512 hash of the quorum key secret
    #[prost(bytes = "vec", tag = "6")]
    pub quorum_key_hash: ::prost::alloc::vec::Vec<u8>,
    /// Test message encrypted to the quorum public key
    #[prost(bytes = "vec", tag = "7")]
    pub test_message_ciphertext: ::prost::alloc::vec::Vec<u8>,
    /// Signature over the test message by the quorum key
    #[prost(bytes = "vec", tag = "8")]
    pub test_message_signature: ::prost::alloc::vec::Vec<u8>,
    /// The message used for the test signature and ciphertext
    #[prost(bytes = "vec", tag = "9")]
    pub test_message: ::prost::alloc::vec::Vec<u8>,
}
/// Request type for the Nitro Secure Module API.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NsmRequest {
    #[prost(oneof = "nsm_request::Request", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub request: ::core::option::Option<nsm_request::Request>,
}
/// Nested message and enum types in `NsmRequest`.
pub mod nsm_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        DescribePcr(super::DescribePcrRequest),
        #[prost(message, tag = "2")]
        ExtendPcr(super::ExtendPcrRequest),
        #[prost(message, tag = "3")]
        LockPcr(super::LockPcrRequest),
        #[prost(message, tag = "4")]
        LockPcrs(super::LockPcrsRequest),
        #[prost(message, tag = "5")]
        DescribeNsm(super::DescribeNsmRequest),
        #[prost(message, tag = "6")]
        Attestation(super::AttestationRequest),
        #[prost(message, tag = "7")]
        GetRandom(super::GetRandomRequest),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DescribePcrRequest {
    #[prost(uint32, tag = "1")]
    pub index: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendPcrRequest {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockPcrRequest {
    #[prost(uint32, tag = "1")]
    pub index: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockPcrsRequest {
    #[prost(uint32, tag = "1")]
    pub range: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DescribeNsmRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttestationRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub user_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub nonce: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub public_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRandomRequest {}
/// Response type for the Nitro Secure Module API.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NsmResponse {
    #[prost(oneof = "nsm_response::Response", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
    pub response: ::core::option::Option<nsm_response::Response>,
}
/// Nested message and enum types in `NsmResponse`.
pub mod nsm_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        DescribePcr(super::DescribePcrResponse),
        #[prost(message, tag = "2")]
        ExtendPcr(super::ExtendPcrResponse),
        #[prost(message, tag = "3")]
        LockPcr(super::LockPcrResponse),
        #[prost(message, tag = "4")]
        LockPcrs(super::LockPcrsResponse),
        #[prost(message, tag = "5")]
        DescribeNsm(super::DescribeNsmResponse),
        #[prost(message, tag = "6")]
        Attestation(super::AttestationResponse),
        #[prost(message, tag = "7")]
        GetRandom(super::GetRandomResponse),
        #[prost(message, tag = "8")]
        Error(super::NsmErrorResponse),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribePcrResponse {
    #[prost(bool, tag = "1")]
    pub lock: bool,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendPcrResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockPcrResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockPcrsResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeNsmResponse {
    #[prost(uint32, tag = "1")]
    pub version_major: u32,
    #[prost(uint32, tag = "2")]
    pub version_minor: u32,
    #[prost(uint32, tag = "3")]
    pub version_patch: u32,
    #[prost(string, tag = "4")]
    pub module_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub max_pcrs: u32,
    /// Note: Using repeated instead of a set for deterministic ordering
    #[prost(uint32, repeated, tag = "6")]
    pub locked_pcrs: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "NsmDigest", tag = "7")]
    pub digest: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttestationResponse {
    /// COSE Sign1 structure containing CBOR-encoded AttestationDocument
    #[prost(bytes = "vec", tag = "1")]
    pub document: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRandomResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub random: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NsmErrorResponse {
    #[prost(enumeration = "NsmErrorCode", tag = "1")]
    pub code: i32,
}
/// Possible error codes from the Nitro Secure Module API.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NsmErrorCode {
    Success = 0,
    InvalidArgument = 1,
    InvalidIndex = 2,
    InvalidResponse = 3,
    ReadOnlyIndex = 4,
    InvalidOperation = 5,
    BufferTooSmall = 6,
    InputTooLarge = 7,
    InternalError = 8,
}
impl NsmErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Success => "NSM_ERROR_CODE_SUCCESS",
            Self::InvalidArgument => "NSM_ERROR_CODE_INVALID_ARGUMENT",
            Self::InvalidIndex => "NSM_ERROR_CODE_INVALID_INDEX",
            Self::InvalidResponse => "NSM_ERROR_CODE_INVALID_RESPONSE",
            Self::ReadOnlyIndex => "NSM_ERROR_CODE_READ_ONLY_INDEX",
            Self::InvalidOperation => "NSM_ERROR_CODE_INVALID_OPERATION",
            Self::BufferTooSmall => "NSM_ERROR_CODE_BUFFER_TOO_SMALL",
            Self::InputTooLarge => "NSM_ERROR_CODE_INPUT_TOO_LARGE",
            Self::InternalError => "NSM_ERROR_CODE_INTERNAL_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NSM_ERROR_CODE_SUCCESS" => Some(Self::Success),
            "NSM_ERROR_CODE_INVALID_ARGUMENT" => Some(Self::InvalidArgument),
            "NSM_ERROR_CODE_INVALID_INDEX" => Some(Self::InvalidIndex),
            "NSM_ERROR_CODE_INVALID_RESPONSE" => Some(Self::InvalidResponse),
            "NSM_ERROR_CODE_READ_ONLY_INDEX" => Some(Self::ReadOnlyIndex),
            "NSM_ERROR_CODE_INVALID_OPERATION" => Some(Self::InvalidOperation),
            "NSM_ERROR_CODE_BUFFER_TOO_SMALL" => Some(Self::BufferTooSmall),
            "NSM_ERROR_CODE_INPUT_TOO_LARGE" => Some(Self::InputTooLarge),
            "NSM_ERROR_CODE_INTERNAL_ERROR" => Some(Self::InternalError),
            _ => None,
        }
    }
}
/// Possible hash digests for the Nitro Secure Module API.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NsmDigest {
    Unspecified = 0,
    Sha256 = 1,
    Sha384 = 2,
    Sha512 = 3,
}
impl NsmDigest {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NSM_DIGEST_UNSPECIFIED",
            Self::Sha256 => "NSM_DIGEST_SHA256",
            Self::Sha384 => "NSM_DIGEST_SHA384",
            Self::Sha512 => "NSM_DIGEST_SHA512",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NSM_DIGEST_UNSPECIFIED" => Some(Self::Unspecified),
            "NSM_DIGEST_SHA256" => Some(Self::Sha256),
            "NSM_DIGEST_SHA384" => Some(Self::Sha384),
            "NSM_DIGEST_SHA512" => Some(Self::Sha512),
            _ => None,
        }
    }
}
/// Protocol message - the main RPC type for client-enclave communication.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolMsg {
    #[prost(
        oneof = "protocol_msg::Msg",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21"
    )]
    pub msg: ::core::option::Option<protocol_msg::Msg>,
}
/// Nested message and enum types in `ProtocolMsg`.
pub mod protocol_msg {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Msg {
        #[prost(message, tag = "1")]
        ErrorResponse(super::ProtocolError),
        /// Status
        #[prost(message, tag = "2")]
        StatusRequest(super::StatusRequest),
        #[prost(message, tag = "3")]
        StatusResponse(super::StatusResponse),
        /// Boot flows
        #[prost(message, tag = "4")]
        BootStandardRequest(super::BootStandardRequest),
        #[prost(message, tag = "5")]
        BootStandardResponse(super::BootStandardResponse),
        #[prost(message, tag = "6")]
        BootGenesisRequest(super::BootGenesisRequest),
        #[prost(message, tag = "7")]
        BootGenesisResponse(super::BootGenesisResponse),
        #[prost(message, tag = "8")]
        BootKeyForwardRequest(super::BootKeyForwardRequest),
        #[prost(message, tag = "9")]
        BootKeyForwardResponse(super::BootKeyForwardResponse),
        /// Provisioning
        #[prost(message, tag = "10")]
        ProvisionRequest(super::ProvisionRequest),
        #[prost(message, tag = "11")]
        ProvisionResponse(super::ProvisionResponse),
        /// Proxy
        #[prost(message, tag = "12")]
        ProxyRequest(super::ProxyRequest),
        #[prost(message, tag = "13")]
        ProxyResponse(super::ProxyResponse),
        /// Attestation
        #[prost(message, tag = "14")]
        LiveAttestationDocRequest(super::LiveAttestationDocRequest),
        #[prost(message, tag = "15")]
        LiveAttestationDocResponse(super::LiveAttestationDocResponse),
        /// Key operations
        #[prost(message, tag = "16")]
        ExportKeyRequest(super::ExportKeyRequest),
        #[prost(message, tag = "17")]
        ExportKeyResponse(super::ExportKeyResponse),
        #[prost(message, tag = "18")]
        InjectKeyRequest(super::InjectKeyRequest),
        #[prost(message, tag = "19")]
        InjectKeyResponse(super::InjectKeyResponse),
        /// Manifest
        #[prost(message, tag = "20")]
        ManifestEnvelopeRequest(super::ManifestEnvelopeRequest),
        #[prost(message, tag = "21")]
        ManifestEnvelopeResponse(super::ManifestEnvelopeResponse),
    }
}
/// Status request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatusRequest {}
/// Status response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatusResponse {
    #[prost(enumeration = "ProtocolPhase", tag = "1")]
    pub phase: i32,
}
/// Standard boot request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootStandardRequest {
    #[prost(message, optional, tag = "1")]
    pub manifest_envelope: ::core::option::Option<ManifestEnvelope>,
    #[prost(bytes = "vec", tag = "2")]
    pub pivot: ::prost::alloc::vec::Vec<u8>,
}
/// Standard boot response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootStandardResponse {
    #[prost(message, optional, tag = "1")]
    pub nsm_response: ::core::option::Option<NsmResponse>,
}
/// Genesis boot request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootGenesisRequest {
    #[prost(message, optional, tag = "1")]
    pub set: ::core::option::Option<GenesisSet>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub dr_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Genesis boot response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootGenesisResponse {
    #[prost(message, optional, tag = "1")]
    pub nsm_response: ::core::option::Option<NsmResponse>,
    #[prost(message, optional, tag = "2")]
    pub genesis_output: ::core::option::Option<GenesisOutput>,
}
/// Key forward boot request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootKeyForwardRequest {
    #[prost(message, optional, tag = "1")]
    pub manifest_envelope: ::core::option::Option<ManifestEnvelope>,
    #[prost(bytes = "vec", tag = "2")]
    pub pivot: ::prost::alloc::vec::Vec<u8>,
}
/// Key forward boot response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootKeyForwardResponse {
    #[prost(message, optional, tag = "1")]
    pub nsm_response: ::core::option::Option<NsmResponse>,
}
/// Provision request - post a quorum key shard
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionRequest {
    /// Quorum key share encrypted to the Ephemeral Key
    #[prost(bytes = "vec", tag = "1")]
    pub share: ::prost::alloc::vec::Vec<u8>,
    /// Approval of the manifest from a share set member
    #[prost(message, optional, tag = "2")]
    pub approval: ::core::option::Option<Approval>,
}
/// Provision response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProvisionResponse {
    /// True if the quorum key was reconstructed
    #[prost(bool, tag = "1")]
    pub reconstructed: bool,
}
/// Proxy request - forward data to the secure app
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProxyRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Proxy response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProxyResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Live attestation document request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LiveAttestationDocRequest {}
/// Live attestation document response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveAttestationDocResponse {
    #[prost(message, optional, tag = "1")]
    pub nsm_response: ::core::option::Option<NsmResponse>,
    #[prost(message, optional, tag = "2")]
    pub manifest_envelope: ::core::option::Option<ManifestEnvelope>,
}
/// Export key request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub manifest_envelope: ::core::option::Option<ManifestEnvelope>,
    /// Attestation document from the requesting enclave
    #[prost(bytes = "vec", tag = "2")]
    pub cose_sign1_attestation_doc: ::prost::alloc::vec::Vec<u8>,
}
/// Export key response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportKeyResponse {
    /// Quorum key encrypted to the Ephemeral Key
    #[prost(bytes = "vec", tag = "1")]
    pub encrypted_quorum_key: ::prost::alloc::vec::Vec<u8>,
    /// Signature over the encrypted quorum key
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// Inject key request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InjectKeyRequest {
    /// Quorum key encrypted to this enclave's Ephemeral Key
    #[prost(bytes = "vec", tag = "1")]
    pub encrypted_quorum_key: ::prost::alloc::vec::Vec<u8>,
    /// Signature over the encrypted quorum key
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// Inject key response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InjectKeyResponse {}
/// Manifest envelope request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManifestEnvelopeRequest {}
/// Manifest envelope response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManifestEnvelopeResponse {
    #[prost(message, optional, tag = "1")]
    pub manifest_envelope: ::core::option::Option<ManifestEnvelope>,
}
/// Protocol error - code and message only.
/// Error details are interpolated into the message using Display.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolError {
    #[prost(enumeration = "ProtocolErrorCode", tag = "1")]
    pub code: i32,
    /// Human-readable error message with details interpolated
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Protocol execution phase.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtocolPhase {
    Unspecified = 0,
    UnrecoverableError = 1,
    WaitingForBootInstruction = 2,
    GenesisBooted = 3,
    WaitingForQuorumShards = 4,
    QuorumKeyProvisioned = 5,
    WaitingForForwardedKey = 6,
}
impl ProtocolPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROTOCOL_PHASE_UNSPECIFIED",
            Self::UnrecoverableError => "PROTOCOL_PHASE_UNRECOVERABLE_ERROR",
            Self::WaitingForBootInstruction => {
                "PROTOCOL_PHASE_WAITING_FOR_BOOT_INSTRUCTION"
            }
            Self::GenesisBooted => "PROTOCOL_PHASE_GENESIS_BOOTED",
            Self::WaitingForQuorumShards => "PROTOCOL_PHASE_WAITING_FOR_QUORUM_SHARDS",
            Self::QuorumKeyProvisioned => "PROTOCOL_PHASE_QUORUM_KEY_PROVISIONED",
            Self::WaitingForForwardedKey => "PROTOCOL_PHASE_WAITING_FOR_FORWARDED_KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOCOL_PHASE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROTOCOL_PHASE_UNRECOVERABLE_ERROR" => Some(Self::UnrecoverableError),
            "PROTOCOL_PHASE_WAITING_FOR_BOOT_INSTRUCTION" => {
                Some(Self::WaitingForBootInstruction)
            }
            "PROTOCOL_PHASE_GENESIS_BOOTED" => Some(Self::GenesisBooted),
            "PROTOCOL_PHASE_WAITING_FOR_QUORUM_SHARDS" => {
                Some(Self::WaitingForQuorumShards)
            }
            "PROTOCOL_PHASE_QUORUM_KEY_PROVISIONED" => Some(Self::QuorumKeyProvisioned),
            "PROTOCOL_PHASE_WAITING_FOR_FORWARDED_KEY" => {
                Some(Self::WaitingForForwardedKey)
            }
            _ => None,
        }
    }
}
/// Protocol error codes
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtocolErrorCode {
    Unspecified = 0,
    InvalidShare = 1,
    ReconstructionErrorEmptySecret = 2,
    ReconstructionErrorIncorrectPubKey = 3,
    IoError = 4,
    InvalidManifestApproval = 5,
    NotEnoughApprovals = 6,
    NoMatchingRoute = 7,
    InvalidPivotHash = 8,
    OversizeMsg = 9,
    InvalidMsg = 10,
    EnclaveClient = 11,
    DecryptionFailed = 12,
    InvalidPrivateKey = 13,
    FailedToParseFromString = 14,
    BadEphemeralKeyPath = 15,
    CannotModifyPostPivotStatic = 16,
    FailedToGetEphemeralKey = 17,
    FailedToPutEphemeralKey = 18,
    CannotRotateNonExistentEphemeralKey = 19,
    CannotDeleteEphemeralKey = 20,
    FailedToGetQuorumKey = 21,
    FailedToPutQuorumKey = 22,
    FailedToGetManifestEnvelope = 23,
    FailedToPutManifestEnvelope = 24,
    FailedToPutPivot = 25,
    AppClientRecvTimeout = 26,
    AppClientRecvInterrupted = 27,
    AppClientRecvConnectionClosed = 28,
    AppClientConnectError = 29,
    AppClientSendError = 30,
    AppClientError = 31,
    OversizedPayload = 32,
    ProtocolMsgDeserialization = 33,
    BadShareSetApprovals = 34,
    CouldNotVerifyApproval = 35,
    NotShareSetMember = 36,
    NotManifestSetMember = 37,
    P256Error = 38,
    InvalidP256DrKey = 39,
    IncorrectSecretLen = 40,
    QosAttestError = 41,
    DifferentQuorumKey = 42,
    DifferentManifestSet = 43,
    DifferentNamespaceName = 44,
    LowNonce = 45,
    DifferentPcr0 = 46,
    DifferentPcr1 = 47,
    DifferentPcr2 = 48,
    DifferentPcr3 = 49,
    MissingEphemeralKey = 50,
    InvalidEphemeralKey = 51,
    InvalidEncryptedQuorumKeySignature = 52,
    EncryptedQuorumKeyInvalidLen = 53,
    InvalidQuorumSecret = 54,
    WrongQuorumKey = 55,
    InvalidStateTransition = 56,
    DuplicateApproval = 57,
    DifferentManifest = 58,
    QosCrypto = 59,
    PoolExpandError = 60,
}
impl ProtocolErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROTOCOL_ERROR_CODE_UNSPECIFIED",
            Self::InvalidShare => "PROTOCOL_ERROR_CODE_INVALID_SHARE",
            Self::ReconstructionErrorEmptySecret => {
                "PROTOCOL_ERROR_CODE_RECONSTRUCTION_ERROR_EMPTY_SECRET"
            }
            Self::ReconstructionErrorIncorrectPubKey => {
                "PROTOCOL_ERROR_CODE_RECONSTRUCTION_ERROR_INCORRECT_PUB_KEY"
            }
            Self::IoError => "PROTOCOL_ERROR_CODE_IO_ERROR",
            Self::InvalidManifestApproval => {
                "PROTOCOL_ERROR_CODE_INVALID_MANIFEST_APPROVAL"
            }
            Self::NotEnoughApprovals => "PROTOCOL_ERROR_CODE_NOT_ENOUGH_APPROVALS",
            Self::NoMatchingRoute => "PROTOCOL_ERROR_CODE_NO_MATCHING_ROUTE",
            Self::InvalidPivotHash => "PROTOCOL_ERROR_CODE_INVALID_PIVOT_HASH",
            Self::OversizeMsg => "PROTOCOL_ERROR_CODE_OVERSIZE_MSG",
            Self::InvalidMsg => "PROTOCOL_ERROR_CODE_INVALID_MSG",
            Self::EnclaveClient => "PROTOCOL_ERROR_CODE_ENCLAVE_CLIENT",
            Self::DecryptionFailed => "PROTOCOL_ERROR_CODE_DECRYPTION_FAILED",
            Self::InvalidPrivateKey => "PROTOCOL_ERROR_CODE_INVALID_PRIVATE_KEY",
            Self::FailedToParseFromString => {
                "PROTOCOL_ERROR_CODE_FAILED_TO_PARSE_FROM_STRING"
            }
            Self::BadEphemeralKeyPath => "PROTOCOL_ERROR_CODE_BAD_EPHEMERAL_KEY_PATH",
            Self::CannotModifyPostPivotStatic => {
                "PROTOCOL_ERROR_CODE_CANNOT_MODIFY_POST_PIVOT_STATIC"
            }
            Self::FailedToGetEphemeralKey => {
                "PROTOCOL_ERROR_CODE_FAILED_TO_GET_EPHEMERAL_KEY"
            }
            Self::FailedToPutEphemeralKey => {
                "PROTOCOL_ERROR_CODE_FAILED_TO_PUT_EPHEMERAL_KEY"
            }
            Self::CannotRotateNonExistentEphemeralKey => {
                "PROTOCOL_ERROR_CODE_CANNOT_ROTATE_NON_EXISTENT_EPHEMERAL_KEY"
            }
            Self::CannotDeleteEphemeralKey => {
                "PROTOCOL_ERROR_CODE_CANNOT_DELETE_EPHEMERAL_KEY"
            }
            Self::FailedToGetQuorumKey => "PROTOCOL_ERROR_CODE_FAILED_TO_GET_QUORUM_KEY",
            Self::FailedToPutQuorumKey => "PROTOCOL_ERROR_CODE_FAILED_TO_PUT_QUORUM_KEY",
            Self::FailedToGetManifestEnvelope => {
                "PROTOCOL_ERROR_CODE_FAILED_TO_GET_MANIFEST_ENVELOPE"
            }
            Self::FailedToPutManifestEnvelope => {
                "PROTOCOL_ERROR_CODE_FAILED_TO_PUT_MANIFEST_ENVELOPE"
            }
            Self::FailedToPutPivot => "PROTOCOL_ERROR_CODE_FAILED_TO_PUT_PIVOT",
            Self::AppClientRecvTimeout => "PROTOCOL_ERROR_CODE_APP_CLIENT_RECV_TIMEOUT",
            Self::AppClientRecvInterrupted => {
                "PROTOCOL_ERROR_CODE_APP_CLIENT_RECV_INTERRUPTED"
            }
            Self::AppClientRecvConnectionClosed => {
                "PROTOCOL_ERROR_CODE_APP_CLIENT_RECV_CONNECTION_CLOSED"
            }
            Self::AppClientConnectError => "PROTOCOL_ERROR_CODE_APP_CLIENT_CONNECT_ERROR",
            Self::AppClientSendError => "PROTOCOL_ERROR_CODE_APP_CLIENT_SEND_ERROR",
            Self::AppClientError => "PROTOCOL_ERROR_CODE_APP_CLIENT_ERROR",
            Self::OversizedPayload => "PROTOCOL_ERROR_CODE_OVERSIZED_PAYLOAD",
            Self::ProtocolMsgDeserialization => {
                "PROTOCOL_ERROR_CODE_PROTOCOL_MSG_DESERIALIZATION"
            }
            Self::BadShareSetApprovals => "PROTOCOL_ERROR_CODE_BAD_SHARE_SET_APPROVALS",
            Self::CouldNotVerifyApproval => {
                "PROTOCOL_ERROR_CODE_COULD_NOT_VERIFY_APPROVAL"
            }
            Self::NotShareSetMember => "PROTOCOL_ERROR_CODE_NOT_SHARE_SET_MEMBER",
            Self::NotManifestSetMember => "PROTOCOL_ERROR_CODE_NOT_MANIFEST_SET_MEMBER",
            Self::P256Error => "PROTOCOL_ERROR_CODE_P256_ERROR",
            Self::InvalidP256DrKey => "PROTOCOL_ERROR_CODE_INVALID_P256_DR_KEY",
            Self::IncorrectSecretLen => "PROTOCOL_ERROR_CODE_INCORRECT_SECRET_LEN",
            Self::QosAttestError => "PROTOCOL_ERROR_CODE_QOS_ATTEST_ERROR",
            Self::DifferentQuorumKey => "PROTOCOL_ERROR_CODE_DIFFERENT_QUORUM_KEY",
            Self::DifferentManifestSet => "PROTOCOL_ERROR_CODE_DIFFERENT_MANIFEST_SET",
            Self::DifferentNamespaceName => {
                "PROTOCOL_ERROR_CODE_DIFFERENT_NAMESPACE_NAME"
            }
            Self::LowNonce => "PROTOCOL_ERROR_CODE_LOW_NONCE",
            Self::DifferentPcr0 => "PROTOCOL_ERROR_CODE_DIFFERENT_PCR0",
            Self::DifferentPcr1 => "PROTOCOL_ERROR_CODE_DIFFERENT_PCR1",
            Self::DifferentPcr2 => "PROTOCOL_ERROR_CODE_DIFFERENT_PCR2",
            Self::DifferentPcr3 => "PROTOCOL_ERROR_CODE_DIFFERENT_PCR3",
            Self::MissingEphemeralKey => "PROTOCOL_ERROR_CODE_MISSING_EPHEMERAL_KEY",
            Self::InvalidEphemeralKey => "PROTOCOL_ERROR_CODE_INVALID_EPHEMERAL_KEY",
            Self::InvalidEncryptedQuorumKeySignature => {
                "PROTOCOL_ERROR_CODE_INVALID_ENCRYPTED_QUORUM_KEY_SIGNATURE"
            }
            Self::EncryptedQuorumKeyInvalidLen => {
                "PROTOCOL_ERROR_CODE_ENCRYPTED_QUORUM_KEY_INVALID_LEN"
            }
            Self::InvalidQuorumSecret => "PROTOCOL_ERROR_CODE_INVALID_QUORUM_SECRET",
            Self::WrongQuorumKey => "PROTOCOL_ERROR_CODE_WRONG_QUORUM_KEY",
            Self::InvalidStateTransition => {
                "PROTOCOL_ERROR_CODE_INVALID_STATE_TRANSITION"
            }
            Self::DuplicateApproval => "PROTOCOL_ERROR_CODE_DUPLICATE_APPROVAL",
            Self::DifferentManifest => "PROTOCOL_ERROR_CODE_DIFFERENT_MANIFEST",
            Self::QosCrypto => "PROTOCOL_ERROR_CODE_QOS_CRYPTO",
            Self::PoolExpandError => "PROTOCOL_ERROR_CODE_POOL_EXPAND_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOCOL_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROTOCOL_ERROR_CODE_INVALID_SHARE" => Some(Self::InvalidShare),
            "PROTOCOL_ERROR_CODE_RECONSTRUCTION_ERROR_EMPTY_SECRET" => {
                Some(Self::ReconstructionErrorEmptySecret)
            }
            "PROTOCOL_ERROR_CODE_RECONSTRUCTION_ERROR_INCORRECT_PUB_KEY" => {
                Some(Self::ReconstructionErrorIncorrectPubKey)
            }
            "PROTOCOL_ERROR_CODE_IO_ERROR" => Some(Self::IoError),
            "PROTOCOL_ERROR_CODE_INVALID_MANIFEST_APPROVAL" => {
                Some(Self::InvalidManifestApproval)
            }
            "PROTOCOL_ERROR_CODE_NOT_ENOUGH_APPROVALS" => Some(Self::NotEnoughApprovals),
            "PROTOCOL_ERROR_CODE_NO_MATCHING_ROUTE" => Some(Self::NoMatchingRoute),
            "PROTOCOL_ERROR_CODE_INVALID_PIVOT_HASH" => Some(Self::InvalidPivotHash),
            "PROTOCOL_ERROR_CODE_OVERSIZE_MSG" => Some(Self::OversizeMsg),
            "PROTOCOL_ERROR_CODE_INVALID_MSG" => Some(Self::InvalidMsg),
            "PROTOCOL_ERROR_CODE_ENCLAVE_CLIENT" => Some(Self::EnclaveClient),
            "PROTOCOL_ERROR_CODE_DECRYPTION_FAILED" => Some(Self::DecryptionFailed),
            "PROTOCOL_ERROR_CODE_INVALID_PRIVATE_KEY" => Some(Self::InvalidPrivateKey),
            "PROTOCOL_ERROR_CODE_FAILED_TO_PARSE_FROM_STRING" => {
                Some(Self::FailedToParseFromString)
            }
            "PROTOCOL_ERROR_CODE_BAD_EPHEMERAL_KEY_PATH" => {
                Some(Self::BadEphemeralKeyPath)
            }
            "PROTOCOL_ERROR_CODE_CANNOT_MODIFY_POST_PIVOT_STATIC" => {
                Some(Self::CannotModifyPostPivotStatic)
            }
            "PROTOCOL_ERROR_CODE_FAILED_TO_GET_EPHEMERAL_KEY" => {
                Some(Self::FailedToGetEphemeralKey)
            }
            "PROTOCOL_ERROR_CODE_FAILED_TO_PUT_EPHEMERAL_KEY" => {
                Some(Self::FailedToPutEphemeralKey)
            }
            "PROTOCOL_ERROR_CODE_CANNOT_ROTATE_NON_EXISTENT_EPHEMERAL_KEY" => {
                Some(Self::CannotRotateNonExistentEphemeralKey)
            }
            "PROTOCOL_ERROR_CODE_CANNOT_DELETE_EPHEMERAL_KEY" => {
                Some(Self::CannotDeleteEphemeralKey)
            }
            "PROTOCOL_ERROR_CODE_FAILED_TO_GET_QUORUM_KEY" => {
                Some(Self::FailedToGetQuorumKey)
            }
            "PROTOCOL_ERROR_CODE_FAILED_TO_PUT_QUORUM_KEY" => {
                Some(Self::FailedToPutQuorumKey)
            }
            "PROTOCOL_ERROR_CODE_FAILED_TO_GET_MANIFEST_ENVELOPE" => {
                Some(Self::FailedToGetManifestEnvelope)
            }
            "PROTOCOL_ERROR_CODE_FAILED_TO_PUT_MANIFEST_ENVELOPE" => {
                Some(Self::FailedToPutManifestEnvelope)
            }
            "PROTOCOL_ERROR_CODE_FAILED_TO_PUT_PIVOT" => Some(Self::FailedToPutPivot),
            "PROTOCOL_ERROR_CODE_APP_CLIENT_RECV_TIMEOUT" => {
                Some(Self::AppClientRecvTimeout)
            }
            "PROTOCOL_ERROR_CODE_APP_CLIENT_RECV_INTERRUPTED" => {
                Some(Self::AppClientRecvInterrupted)
            }
            "PROTOCOL_ERROR_CODE_APP_CLIENT_RECV_CONNECTION_CLOSED" => {
                Some(Self::AppClientRecvConnectionClosed)
            }
            "PROTOCOL_ERROR_CODE_APP_CLIENT_CONNECT_ERROR" => {
                Some(Self::AppClientConnectError)
            }
            "PROTOCOL_ERROR_CODE_APP_CLIENT_SEND_ERROR" => Some(Self::AppClientSendError),
            "PROTOCOL_ERROR_CODE_APP_CLIENT_ERROR" => Some(Self::AppClientError),
            "PROTOCOL_ERROR_CODE_OVERSIZED_PAYLOAD" => Some(Self::OversizedPayload),
            "PROTOCOL_ERROR_CODE_PROTOCOL_MSG_DESERIALIZATION" => {
                Some(Self::ProtocolMsgDeserialization)
            }
            "PROTOCOL_ERROR_CODE_BAD_SHARE_SET_APPROVALS" => {
                Some(Self::BadShareSetApprovals)
            }
            "PROTOCOL_ERROR_CODE_COULD_NOT_VERIFY_APPROVAL" => {
                Some(Self::CouldNotVerifyApproval)
            }
            "PROTOCOL_ERROR_CODE_NOT_SHARE_SET_MEMBER" => Some(Self::NotShareSetMember),
            "PROTOCOL_ERROR_CODE_NOT_MANIFEST_SET_MEMBER" => {
                Some(Self::NotManifestSetMember)
            }
            "PROTOCOL_ERROR_CODE_P256_ERROR" => Some(Self::P256Error),
            "PROTOCOL_ERROR_CODE_INVALID_P256_DR_KEY" => Some(Self::InvalidP256DrKey),
            "PROTOCOL_ERROR_CODE_INCORRECT_SECRET_LEN" => Some(Self::IncorrectSecretLen),
            "PROTOCOL_ERROR_CODE_QOS_ATTEST_ERROR" => Some(Self::QosAttestError),
            "PROTOCOL_ERROR_CODE_DIFFERENT_QUORUM_KEY" => Some(Self::DifferentQuorumKey),
            "PROTOCOL_ERROR_CODE_DIFFERENT_MANIFEST_SET" => {
                Some(Self::DifferentManifestSet)
            }
            "PROTOCOL_ERROR_CODE_DIFFERENT_NAMESPACE_NAME" => {
                Some(Self::DifferentNamespaceName)
            }
            "PROTOCOL_ERROR_CODE_LOW_NONCE" => Some(Self::LowNonce),
            "PROTOCOL_ERROR_CODE_DIFFERENT_PCR0" => Some(Self::DifferentPcr0),
            "PROTOCOL_ERROR_CODE_DIFFERENT_PCR1" => Some(Self::DifferentPcr1),
            "PROTOCOL_ERROR_CODE_DIFFERENT_PCR2" => Some(Self::DifferentPcr2),
            "PROTOCOL_ERROR_CODE_DIFFERENT_PCR3" => Some(Self::DifferentPcr3),
            "PROTOCOL_ERROR_CODE_MISSING_EPHEMERAL_KEY" => {
                Some(Self::MissingEphemeralKey)
            }
            "PROTOCOL_ERROR_CODE_INVALID_EPHEMERAL_KEY" => {
                Some(Self::InvalidEphemeralKey)
            }
            "PROTOCOL_ERROR_CODE_INVALID_ENCRYPTED_QUORUM_KEY_SIGNATURE" => {
                Some(Self::InvalidEncryptedQuorumKeySignature)
            }
            "PROTOCOL_ERROR_CODE_ENCRYPTED_QUORUM_KEY_INVALID_LEN" => {
                Some(Self::EncryptedQuorumKeyInvalidLen)
            }
            "PROTOCOL_ERROR_CODE_INVALID_QUORUM_SECRET" => {
                Some(Self::InvalidQuorumSecret)
            }
            "PROTOCOL_ERROR_CODE_WRONG_QUORUM_KEY" => Some(Self::WrongQuorumKey),
            "PROTOCOL_ERROR_CODE_INVALID_STATE_TRANSITION" => {
                Some(Self::InvalidStateTransition)
            }
            "PROTOCOL_ERROR_CODE_DUPLICATE_APPROVAL" => Some(Self::DuplicateApproval),
            "PROTOCOL_ERROR_CODE_DIFFERENT_MANIFEST" => Some(Self::DifferentManifest),
            "PROTOCOL_ERROR_CODE_QOS_CRYPTO" => Some(Self::QosCrypto),
            "PROTOCOL_ERROR_CODE_POOL_EXPAND_ERROR" => Some(Self::PoolExpandError),
            _ => None,
        }
    }
}
